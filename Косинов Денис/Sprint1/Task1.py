with open('text.txt', 'r') as f:
    text = f.read()
'''Не стоит бояться длинных названий для переменных. 
Желательно называть переменные осмысленно, чтобы при прочтении была понятна суть значений, которые в нее вносятся.'''
sp = []
sp2 = []
sp3 = []
z = 0
m = 0
st = ''
'''Нет необходимости разделять алфавит на различные массивы и вообще задавать их в коде, 
т.к. в питоне существуют встроенные массивы в библиотеке string. Например:
import string
string.ascii_letters
Вернёт ->
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
'''
alpha = "abcdefghijklmnopqrstuvwxyz"
alph = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
sym = '?-().,"´2013’4& %2:;'
st2 = ""
for i in range(len(text)):
    if text[i] == "." or text[i] == "!" or text[i] == "?":
        ''' Сплит предложений можно выполнять при помощи встроенного метода split, который может принимать в себя и 
    массив символов, по которым строка будет разделена.'''
        sp.append(text[z:i + 1])
        z = i + 1
for i in range(len(sp)):
    for j in range(len(sp[i])):
        if sp[i][j] == "?":
            ''' В python существует оператор in который позволяет проверить, существует ли подстрока.
          Этот метод не позволит ускорить код, однако увеличит читабельность.'''
            sp2.append(sp[m:i])
            m = i
sp2.append(sp[m:i])
'''i используется вне области видимости чего либо, внимательней. В данном случае, как я понял, нет необходимости вообще 
указывать i, т.к. если оставить m: то весь оставшийся текст будет добавллен в массив'''
for i in sp2:
    ''' Очень мутарно реализовано объединение, можно сделать проще, используя join, 
    например строчка sp3 = [''.join(i) for i in sp2] получит тоже самое, что и твой цикл'''
    for j in i:
        st += j
    sp3.append(st)
    st = ""

for i in sp3[1:]:
    for k in range(26):
        for j in i:
            if j in alph:
                st2 += alph[(alph.index(j) + k) % len(alph)]
            if j in alpha:
                st2 += alpha[(alpha.index(j) + k) % len(alpha)]
            if j in sym:
                '''Зачем делать массив символов, ведь по сути можно просто использовать if/elif/else, 
                Пример:
                  if j in alph: большие буквы
                  elif j in alpha: маленькие
                  else: все остальное
              '''
                st2 += str(j)
        '''
          Для человека, который впервые видит этот код не совсем очевидно, что есть что. 
          Стоило сделать какой-то принт о начале брута конкретного блока текста, чтобы было меньше путаницы.
          Также было бы намного удобнее если бы вместе со строкой выводился соответсвующий сдвиг
        '''
        print(st2)
        st2 = ""

'''
    На лицо сильный избыток кода. Множество операций можно было произвести меньшим количеством действий 
        и с меньшим количеством промежуточных переменных.
    Также слишком много использований for, при желании 3 последних верхних цикла можно объединить под один, 
        что сократит время работы кода.
    
    В целом алгоритм верный, однако реализация подкачала. Стоит изучить методы взаимодейсвия со строками и списками,
        это позволит улучшить код как визуально, так и функционально.
'''

