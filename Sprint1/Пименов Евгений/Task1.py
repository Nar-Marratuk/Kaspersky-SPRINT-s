with open('shifr.txt', 'rt') as f1, open('words.txt', 'rt') as f2:
    shifr = f1.read()
    words = f2.read()
'''В принципе метод генерации хороший, однако это бесполезные действия, которые только усложняют и загружают код.
Из за этого время работы, хоть незначительно, но увеличится.'''
alph_small = [chr(i) for i in range(ord('a'), ord('z') + 1)]
alph_big = [chr(i) for i in range(ord('A'), ord('Z') + 1)]
text = ''
shifr_list = []
shifr_ind = []
keys = []
n = 0

for ind, i in enumerate(shifr, start=0):
    if i == '.':
        n = ind
    else:
        pass
    if i == '?':
        shifr_ind.append(n)

for i in range(1, len(shifr_ind)):
    shifr_list.append(shifr[shifr_ind[i - 1]:shifr_ind[i]])
    if i == len(shifr_ind) - 1:
        shifr_list.append(shifr[shifr_ind[-1]:])

def ces(list):
    for z in range(1, 27):
        vocab = [''] * len(list)
        for num, i in enumerate(list, start=0):
            for letter in i:
                if letter in alph_small:
                    vocab[num] += alph_small[(alph_small.index(letter) - z) % len(alph_small)]
                if letter in alph_big:
                    vocab[num] += alph_big[(alph_big.index(letter) - z) % len(alph_big)]
        n = 0
        for i in vocab:
            if i.lower() in words:
                n += 1
        if n >= len(list) // 2 + 1:
            return [''.join(vocab), z]
            '''в break нет необходимости, функция прекратится при вызове return'''
            break


text = ''
new_text = ''

for i in shifr_list[:]:
    i = i.split()
    text += ces(i)[0]
    '''Тут сильно потеряно в оптимизации, т.к. ces вызывается 2 раза на один и тот же кусок текста -> 0.3053291 s.
    Если создать переменную, в которую будет записываться значение ces(i), то скорость работы будет -> 0.1522183 s.
    Выйгрышь по времени в 2 раза, а переменная все равно высвободит память при выходе из области видимости.'''
    keys.append(ces(i)[1])
n = 0

for i in shifr:
    '''Если я правильно понял, то тут лучше использовать in, выйдет просто эффективнее'''
    if alph_big.count(i) == 1 or alph_small.count(i) == 1:
        new_text += text[n]
        n += 1
    else:
        new_text += i

with open('text.txt', 'w') as f:
    f.write(new_text)
'''Тут можно было также использовть запятую и загнать записи в оба файла, под одну область, 
    сократило бы код, но не критично.'''
with open('keys.txt', 'w') as f:
    f.write('keys = ' + '{%s}' % (str(keys).strip('[').strip(']')))
    '''Устаревший метод задания форматных строк. Сейчас существуют более гибкие и удобные способы, советую изучить'''

'''
    Идея с автоматическим поиском сдвига на основе популярных слов хорошая, однако не надежная. За идею и старания лайк.
    Итог:
        В целом, алгоритм интересный и рабочий, видно неплохое знание синтаксиса и конструкций языка, 
        однако есть свои недостатки.
        Во-первых, организация кода. Код немного громоздкий и не очень хорошо структурирован. 
        Раз уж используется функция ces, то стоило и добавить main, а кое-какие действия вынести в другие функции, 
        это сделало бы код более эстетичным и читабельным.
        Во-вторых, оптимизация. По данному коду можно увидеть, что есть нормальные знания языка, поэтому на таком уровне
        стоит начинать изучать моменты связанные с оптимизацией кода. Например, следить за глобальными переменными,
        которые просто висят и ничего не делают, также стоит следить за повторным вызовом функций 
        с одинаковыми параметрами, а также, советую изучить сложные динамические структуры данных, которые находятся 
        в библиотеке collections и использования регулярных выражений, с помощью библиотеке re, 
        просто для прокачки навыков. 
'''
